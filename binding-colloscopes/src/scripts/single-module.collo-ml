// ==================== REIFICATIONS ====================

// From interrogation_has_groups.collo-ml
let interrogation_has_groups(interrogation: Interrogation) -> Constraint =
    sum group in interrogation.group_list.groups {
        $GroupInInterrogation(interrogation, group.num)
    } >== 1;

reify interrogation_has_groups as $InterrogationHasGroups;

// From student_in_group.collo-ml
let student_in_group(student: Student, group: Group) -> Constraint =
    $StudentGroup(student, group.group_list) === group.num;

reify student_in_group as $StudentInGroup;

// From group_has_students.collo-ml
let group_has_students(group: Group) -> Constraint =
    sum student in group.group_list.students {
        $StudentInGroup(student, group)
    } + |group.prefilled_students| >== 1;

reify group_has_students as $GroupHasStudents;

// From student_at_interrogation.collo-ml
let student_at_interrogation_in_group(student: Student, interrogation: Interrogation, group: Group) -> Constraint =
    // Use inequalities to reduce the amount of helper variables
    $StudentInGroup(student, group) >== 1 and $GroupInInterrogation(interrogation, group.num) >== 1;

reify student_at_interrogation_in_group as $StudentAtInterrogationInGroup;

let student_in_prefilled_group(student: Student, group_list: GroupList) -> Bool =
    fold group in group_list.groups with result = false {
        result || student in group.prefilled_students
    };

let student_prefilled_group(student: Student, group_list: GroupList) -> Int =
    // returns -1 if no group corresponds
    fold group in group_list.groups with result = -1 {
        /* with a consistent database only one such group might exists
           but in principle this code returns the last one found */
        if student in group.prefilled_students {
            group.num
        } else {
            result
        }
    };

let student_at_interrogation(student: Student, interrogation: Interrogation) -> Constraint =
    if student_in_prefilled_group(student, interrogation.group_list) {
        $GroupInInterrogation(
            interrogation,
            student_prefilled_group(student, interrogation.group_list)
        )
    } else {
        sum group in interrogation.group_list.groups where !group.sealed {
            $StudentAtInterrogationInGroup(student, interrogation, group)
        }
    } >== 1; // Test for bigger than one: we can't actually exceed it but this will save some reification constraints

reify student_at_interrogation as $StudentAtInterrogation;

// ==================== CONSTRAINTS ====================

// From sealed_groups.collo-ml
let count_extra_students_in_group(group: Group) -> LinExpr =
    sum student in group.group_list.students {
        $StudentInGroup(student, group)
    };

let sealed_groups_constraint() -> Constraint =
    forall group in @[Group] where group.sealed {
        count_extra_students_in_group(group) === 0
    };

// From one_interrogation_at_once.collo-ml
let at_most_one_interrogation(time_slot: TimeSlot, student: Student) -> Constraint =
    sum interrogation in time_slot.interrogations where student in interrogation.students {
        $StudentAtInterrogation(student, interrogation)
    } <== 1;

let one_interrogation_at_once_constraint() -> Constraint =
    forall time_slot in @[TimeSlot] {
        forall student in @[Student] {
            at_most_one_interrogation(time_slot, student)
        }
    };

// From group_count_per_interrogation.collo-ml
let max_group_per_interrogation(interrogation: Interrogation) -> Constraint =
    sum group in interrogation.group_list.groups {
        $GroupInInterrogation(interrogation, group.num)
    } <== interrogation.subject.max_group_per_interrogation;

let min_group_per_interrogation(interrogation: Interrogation) -> Constraint =
    sum group in interrogation.group_list.groups {
        $GroupInInterrogation(interrogation, group.num)
    } >== interrogation.subject.min_group_per_interrogation * $InterrogationHasGroups(interrogation);

let enforce_group_count_per_interrogation(interrogation: Interrogation) -> Constraint =
    max_group_per_interrogation(interrogation) and min_group_per_interrogation(interrogation);

let group_count_per_interrogation_constraint() -> Constraint =
    forall interrogation in @[Interrogation] {
        enforce_group_count_per_interrogation(interrogation)
    };

// From students_per_group.collo-ml
let count_students_in_group(group: Group) -> LinExpr =
    sum student in group.group_list.students {
        $StudentInGroup(student, group)
    } + |group.prefilled_students|;

let enforce_min_students_per_group(group: Group) -> Constraint =
    count_students_in_group(group) >==
        group.group_list.min_students_per_group * $GroupHasStudents(group);

let enforce_max_students_per_group(group: Group) -> Constraint =
    count_students_in_group(group) <== group.group_list.max_students_per_group;

let students_per_group_constraint() -> Constraint =
    forall group in @[Group] {
        enforce_min_students_per_group(group) and
        enforce_max_students_per_group(group)
    };

// From group_count_per_group_list.collo-ml
let count_groups_in_list(group_list: GroupList) -> LinExpr =
    sum group in group_list.groups {
        $GroupHasStudents(group)
    };

let max_groups_per_list(group_list: GroupList) -> Constraint =
    count_groups_in_list(group_list) <== group_list.max_group_count;

let min_groups_per_list(group_list: GroupList) -> Constraint =
    count_groups_in_list(group_list) >== group_list.min_group_count;

let enforce_group_count_per_group_list(group_list: GroupList) -> Constraint =
    max_groups_per_list(group_list) and min_groups_per_list(group_list);

let group_count_per_group_list_constraint() -> Constraint =
    forall group_list in @[GroupList] {
        enforce_group_count_per_group_list(group_list)
    };

// From limits.collo-ml
let count_interrogations_in_day(student: Student, day: Day) -> LinExpr =
    sum time_slot in day.time_slots {
        sum interrogation in time_slot.interrogations where
            (student in interrogation.students) &&
            interrogation.subject.take_into_account
        {
            $StudentAtInterrogation(student, interrogation)
        }
    };

let max_per_day_for(student: Student) -> Constraint =
    forall day in @[Day] where day.week.period in student.periods {
        count_interrogations_in_day(student, day) <== student.max_interrogations_per_day
    };

let max_per_day(hard: Bool) -> Constraint =
    forall student in @[Student] where student.hard_max_interrogations_per_day == hard {
        max_per_day_for(student)
    };

let count_interrogations_in_week(student: Student, week: Week) -> LinExpr =
    sum day in week.days {
        count_interrogations_in_day(student, day)
    };

let max_per_week_for(student: Student) -> Constraint =
    forall week in @[Week] where week.period in student.periods {
        count_interrogations_in_week(student, week) <== student.max_interrogations_per_week
    };

let max_per_week(hard: Bool) -> Constraint =
    forall student in @[Student] where student.hard_max_interrogations_per_week == hard {
        max_per_week_for(student)
    };

let min_per_week_for(student: Student) -> Constraint =
    forall week in @[Week] where week.period in student.periods {
        count_interrogations_in_week(student, week) >== student.min_interrogations_per_week
    };

let min_per_week(hard: Bool) -> Constraint =
    forall student in @[Student] where student.hard_min_interrogations_per_week == hard {
        min_per_week_for(student)
    };

let limits_constraint() -> Constraint = max_per_day(true) and max_per_week(true) and min_per_week(true);

let limits_objective() -> [Constraint] = [max_per_day(false), max_per_week(false), min_per_week(false)];

// From students_have_groups.collo-ml
let enforce_student_has_group(student: Student, group_list: GroupList) -> Constraint =
    $StudentGroup(student, group_list) >== 0;

let enforce_all_studens_have_group(group: Group) -> Constraint =
    forall student in group.group_list.students {
        enforce_student_has_group(student, group.group_list)
    };

let students_have_groups_constraint() -> Constraint =
    forall group in @[Group] {
        enforce_all_studens_have_group(group)
    };

// From interrogation_cost.collo-ml
let interrogation_cost_objective() -> LinExpr =
    sum interrogation in @[Interrogation] where interrogation.cost != 0 {
        interrogation.cost * $InterrogationHasGroups(interrogation)
    };

// From students_per_group_for_subject.collo-ml
let count_students_in_group_for_period(group: Group, subject_period: SubjectPeriod) -> LinExpr =
    sum student in group.group_list.students where student in subject_period.students {
        $StudentInGroup(student, group)
    } + |[student for student in group.prefilled_students where student in subject_period.students]|;

let group_has_students_for_subject(group: Group, subject_period: SubjectPeriod) -> Constraint =
    count_students_in_group_for_period(group, subject_period) >== 1;

reify group_has_students_for_subject as $GroupHasStudentsForSubject;

let enforce_min_students_per_group_for_subject(group: Group, subject_period: SubjectPeriod) -> Constraint =
    count_students_in_group_for_period(group, subject_period) >==
        subject_period.subject.min_students_per_group * $GroupHasStudentsForSubject(group, subject_period);

let enforce_max_students_per_group_for_subject(group: Group, subject_period: SubjectPeriod) -> Constraint =
    count_students_in_group_for_period(group, subject_period) <== subject_period.subject.max_students_per_group;

let students_per_group_for_subject_constraint() -> Constraint =
    forall subject_period in @[SubjectPeriod] where subject_period.group_list != none {
        match subject_period.group_list {
            group_list as GroupList {
                forall group in group_list.groups {
                    enforce_min_students_per_group_for_subject(group, subject_period) and
                    enforce_max_students_per_group_for_subject(group, subject_period)
                }
            }
            _ as None {
                // Will never happen, just put a trivial constraint
                0 === 0
            }
        }
    };

// From incompats.collo-ml
let student_list_for_incompat_week(incompat_week: IncompatWeek) -> [Student] =
    sum period_data in incompat_week.incompat.subject.periods_data where period_data.period == incompat_week.week.period {
        period_data.students
    };

let enforce_saturated_incompat_week(incompat_week: IncompatWeek) -> Constraint =
    forall student in student_list_for_incompat_week(incompat_week) {
        forall slot in incompat_week.slots {
            forall time_slot in slot.time_slots {
                forall interrogation in time_slot.interrogations {
                    $StudentAtInterrogation(student, interrogation) === 0
                }
            }
        }
    };

let student_not_at_incompat_slot(student: Student, slot: IncompatSlot) -> Constraint =
    forall time_slot in slot.time_slots {
        forall interrogation in time_slot.interrogations {
            $StudentAtInterrogation(student, interrogation) === 0
        }
    };

reify student_not_at_incompat_slot as $StudentNotAtIncompatSlot;

let enforce_non_saturated_incompat_week(incompat_week: IncompatWeek) -> Constraint =
    forall student in student_list_for_incompat_week(incompat_week) {
        sum slot in incompat_week.slots {
            $StudentNotAtIncompatSlot(student, slot)
        } >== incompat_week.incompat.minimum_free_slots
    };

let enforce_incompat_week(incompat_week: IncompatWeek) -> Constraint =
    if |incompat_week.slots| == incompat_week.incompat.minimum_free_slots {
        enforce_saturated_incompat_week(incompat_week)
    } else {
        enforce_non_saturated_incompat_week(incompat_week)
    };

let incompats_constraint() -> Constraint =
    forall incompat_week in @[IncompatWeek] {
        enforce_incompat_week(incompat_week)
    };

// From groups_filled_by_ascending_order.collo-ml
let group_is_not_empty_if_next_group_is_not_empty(group: Group) -> Constraint =
    /* this works for last group too - because last+1 is never attributed, the
       corresponding reified variable will always be zero */
    $GroupHasStudents(group) >== $GroupHasStudents(group.next);

let groups_filled_by_ascending_order_constraint() -> Constraint =
    forall group in @[Group] {
        group_is_not_empty_if_next_group_is_not_empty(group)
    };

// ==================== COMBINED FUNCTIONS ====================

pub let constraint() -> Constraint =
    sealed_groups_constraint() and
    one_interrogation_at_once_constraint() and
    group_count_per_interrogation_constraint() and
    students_per_group_constraint() and
    group_count_per_group_list_constraint() and
    limits_constraint() and
    students_have_groups_constraint() and
    students_per_group_for_subject_constraint() and
    incompats_constraint() and
    groups_filled_by_ascending_order_constraint();

pub let objective() -> [Constraint | LinExpr] =
    limits_objective() + [interrogation_cost_objective()];
