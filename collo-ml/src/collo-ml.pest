// ========== General structure ==========
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ (!"##" ~ "#") ~ (!EOL ~ ANY)* }
file = { SOI ~ statement* ~ EOI }

// Raw strings with delimiter syntax
// "..." for basic strings
// ~"..."~ if you need " inside
// ~~"..."~~ if you need "~ inside, etc.
string_literal = @{
    raw_string_5 |
    raw_string_4 |
    raw_string_3 |
    raw_string_2 |
    raw_string_1 |
    raw_string_0
}

raw_string_0 = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
raw_string_1 = @{ "~\"" ~ (!"\"~" ~ ANY)* ~ "\"~" }
raw_string_2 = @{ "~~\"" ~ (!"\"~~" ~ ANY)* ~ "\"~~" }
raw_string_3 = @{ "~~~\"" ~ (!"\"~~~" ~ ANY)* ~ "\"~~~" }
raw_string_4 = @{ "~~~~\"" ~ (!"\"~~~~" ~ ANY)* ~ "\"~~~~" }
raw_string_5 = @{ "~~~~~\"" ~ (!"\"~~~~~" ~ ANY)* ~ "\"~~~~~" }

statement = { let_statement | reify_statement }

docstring = ${
    "##" ~ docstring_content ~ EOL
}
docstring_content = { (!EOL ~ ANY)* }
EOL = _{ "\r\n" | "\n" | "\r" }

ident_char = _{ ASCII_ALPHANUMERIC | "_" }
ident = @{ !(reserved_keyword ~ !ident_char) ~ (ASCII_ALPHA | "_") ~ ident_char* }
reserved_keyword = {
    "Constraint" |
    "LinExpr" |
    "forall" |  // before "for"
    "String" |
    "Never" |
    "false" |
    "reify" |
    "where" |
    "rfold" |
    "match" |
    "panic" |
    "cast" |
    "fold" |
    "with" |
    "else" |
    "true" |
    "Bool" |
    "None" |
    "none" |
    "into" |
    "sum" |
    "Int" |
    "let" |
    "pub" |
    "not" |
    "and" |
    "for" |
    "or" |
    "as" |
    "if" |
    "in"        // shortest, comes last
}

// ========== Reify statements ==========
reify_statement = { docstring* ~ "reify" ~ ident ~ "as" ~ (var_name | var_list_name) ~ ";" }
var_name = ${ "$" ~ ident }
var_list_name = ${ "$[" ~ ident ~ "]" }

// ========== Let statements ==========
let_statement = { docstring* ~ pub_modifier? ~ "let" ~ ident ~ "(" ~ params? ~ ")" ~ "->" ~ type_name ~ "=" ~ expr ~ ";" }
pub_modifier = { "pub" }
params = { param ~ ("," ~ param)* }
param = { ident ~ ":" ~ type_name }

// ========== Type Names ==========
primitive_type = { ident | "None" | "Int" | "Bool" | "LinExpr" | "Constraint" | "String" | "Never" }
type_name = { maybe_type ~ ( "|" ~ maybe_type )* }
maybe_type = { maybe_op* ~ list_type }
maybe_op = @{ "?" }
list_type = {
    "[" ~ type_name? ~ "]" |
    tuple_type |
    primitive_type
}

// Tuple type: (Type1, Type2) or (Type1, Type2, Type3, ...)
// Minimum 2 elements to distinguish from grouping
tuple_type = { "(" ~ type_name ~ "," ~ type_name ~ ("," ~ type_name)* ~ ")" }

// ========== Unified Expressions ==========
expr = { or_expr }

// Logical ops
or_expr = { and_expr ~ (or_op ~ and_expr)* }
and_expr = { not_expr ~ (and_op ~ not_expr)* }
not_expr = { not_op ~ not_expr | forall_expr }

// Quantifiers
forall_expr = { forall | comparison_expr }
forall = { "forall" ~ ident ~ in_op ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }

// Comparisons and membership
comparison_expr = { in_expr | relational_expr }
in_expr = { relational_expr ~ in_op ~ relational_expr }

relational_expr = { add_sub_expr ~ (comp_op ~ add_sub_expr)? }

// Arithmetic
add_sub_expr = { mul_div_mod_expr ~ ((add_op | sub_op) ~ mul_div_mod_expr)* }
mul_div_mod_expr = { type_conversion ~ ((mul_op | div_op | mod_op) ~ type_conversion)* }

type_conversion = { cast_expr ~ ( "into" ~ type_name)? }
cast_expr = { explicit_type ~ (cast_op ~ type_name)? }
cast_op = { "cast?" | "cast!" }
explicit_type = { path ~ ( "as" ~ type_name)? }

path = { primary_expr ~ ("." ~ path_segment)* }
path_segment = { tuple_index | ident }
tuple_index = @{ ASCII_DIGIT+ }

// Primary expressions
primary_expr = {
    let_expr |
    if_expr |
    match_expr |
    sum |
    fold |
    rfold |
    cardinality |
    empty_typed_list | // Must the first list to parse correctly
    list_comprehension |  // Must come before list_literal to parse correctly
    list_range | // Must come before list_literal to parse correctly
    list_literal |
    global_collection |
    var_call |
    var_list_call |
    fn_call |
    string_literal |
    boolean |
    none |
    number |
    neg |
    panic |
    tuple_literal |    // Must come before "(" ~ expr ~ ")" to parse correctly
    ident |
    "(" ~ expr ~ ")"
}

// Tuple literal: (expr, expr) or (expr, expr, expr, ...)
// Minimum 2 elements to distinguish from grouping
tuple_literal = { "(" ~ expr ~ "," ~ expr ~ ("," ~ expr)* ~ ")" }

let_expr = { "let" ~ ident ~ "=" ~ expr ~ "{" ~ expr ~ "}" }
if_expr = { "if" ~ expr ~ "{" ~ expr ~ "}" ~ "else" ~ "{" ~ expr ~ "}" }
match_expr = { "match" ~ expr ~ "{" ~ match_branch* ~ "}" }
match_branch = { ident ~ (as_op ~ type_name)? ~ (into_op ~ type_name)? ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
sum = { "sum" ~ ident ~ in_op ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
fold = { "fold" ~ ident ~ in_op ~ expr ~ with_op ~ ident ~ "=" ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
rfold = { "rfold" ~ ident ~ in_op ~ expr ~ with_op ~ ident ~ "=" ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
cardinality = { "|" ~ expr ~ "|" }
empty_typed_list = { "[" ~ "<" ~ type_name ~ ">" ~ "]" }
list_literal = { "[" ~ "]" | "[" ~ expr ~ ("," ~ expr)* ~ "]" }
list_comprehension = { "[" ~ expr ~ "for" ~ ident ~ in_op ~ expr ~ ("for" ~ ident ~ in_op ~ expr)*  ~ (where_op ~ expr)? ~ "]" }
list_range = { "[" ~ expr ~ ".." ~ expr ~ "]" }
global_collection = { "@" ~ "[" ~ type_name ~ "]" }
var_call = { "$" ~ ident ~ "(" ~ args? ~ ")" }
var_list_call = { "$[" ~ ident ~ "]" ~ "(" ~ args? ~ ")" }
fn_call = { ident ~ "(" ~ args? ~ ")" }
args = { arg ~ ("," ~ arg)* }
arg = { expr }
neg = { "-" ~ expr }
panic = { "panic!" ~ expr }

// Operators
add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "//" }
mod_op = { "%" }
comp_op = { "===" | "<==" | ">==" | "==" | "!=" | "<=" | ">=" | "<" | ">" }
in_op = @{ "in" ~ !ident_char }
or_op = @{ "||" | "or" ~ !ident_char }
and_op = @{ "&&" | "and" ~ !ident_char }
not_op = @{ "!" | "not" ~ !ident_char }

where_op = @{ "where" ~ !ident_char }
with_op = @{ "with" ~ !ident_char }
into_op = @{ "into" ~ !ident_char }
as_op = @{ "as" ~ !ident_char }

boolean = @{ "true" ~ !ident_char | "false" ~ !ident_char }
none = @{ "none"  ~ !ident_char }
number = @{ "-"? ~ ASCII_DIGIT+ }

// ========== Test helpers ==========
expr_complete = { SOI ~ expr ~ EOI }
path_complete = { SOI ~ path ~ EOI }
type_name_complete = { SOI ~ type_name ~ EOI }
let_statement_complete = { SOI ~ let_statement ~ EOI }
reify_statement_complete = { SOI ~ reify_statement ~ EOI }
ident_complete = { SOI ~ ident ~ EOI }
tuple_type_complete = { SOI ~ tuple_type ~ EOI }
tuple_literal_complete = { SOI ~ tuple_literal ~ EOI }
