// ========== General structure ==========
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | (!"///" ~ "//") ~ (!EOL ~ ANY)* }
file = { SOI ~ statement* ~ EOI }

// Raw strings with delimiter syntax
// "..." for basic strings
// ~"..."~ if you need " inside
// ~~"..."~~ if you need "~ inside, etc.
string_literal = @{
    raw_string_5 |
    raw_string_4 |
    raw_string_3 |
    raw_string_2 |
    raw_string_1 |
    raw_string_0
}

raw_string_0 = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
raw_string_1 = @{ "~\"" ~ (!"\"~" ~ ANY)* ~ "\"~" }
raw_string_2 = @{ "~~\"" ~ (!"\"~~" ~ ANY)* ~ "\"~~" }
raw_string_3 = @{ "~~~\"" ~ (!"\"~~~" ~ ANY)* ~ "\"~~~" }
raw_string_4 = @{ "~~~~\"" ~ (!"\"~~~~" ~ ANY)* ~ "\"~~~~" }
raw_string_5 = @{ "~~~~~\"" ~ (!"\"~~~~~" ~ ANY)* ~ "\"~~~~~" }

statement = { import_statement | let_statement | reify_statement | type_statement | enum_statement }

// ========== Import statements ==========
// import "module_name" as mod;    - Named import
// import "module_name" as *;      - Wildcard import (pub items only)
import_statement = { "import" ~ string_literal ~ "as" ~ import_target ~ ";" }
import_target = { wildcard_import | ident }
wildcard_import = { "*" }

docstring = ${
    "///" ~ docstring_content ~ EOL
}
docstring_content = { (!EOL ~ ANY)* }
EOL = _{ "\r\n" | "\n" | "\r" }

ident_char = _{ ASCII_ALPHANUMERIC | "_" }
ident = @{ !(reserved_keyword ~ !ident_char) ~ (ASCII_ALPHA | "_") ~ ident_char* }

// All reserved keywords - language keywords only
// Note: Primitive type names (Int, Bool, LinExpr, etc.) are NOT reserved
// and are handled as regular identifiers, then resolved in semantics.
reserved_keyword = {
    "import" |  // before "in"
    "forall" |  // before "for"
    "false" |
    "reify" |
    "where" |
    "rfold" |
    "match" |
    "panic" |
    "cast" |
    "type" |
    "enum" |
    "fold" |
    "with" |
    "else" |
    "true" |
    "none" |
    "sum" |
    "let" |
    "pub" |
    "not" |
    "and" |
    "for" |
    "or" |
    "as" |
    "if" |
    "in"        // shortest, comes last
}

// ========== Reify statements ==========
reify_statement = { docstring* ~ pub_modifier? ~ "reify" ~ ident ~ "as" ~ (var_name | var_list_name) ~ ";" }
var_name = ${ "$" ~ ident }
var_list_name = ${ "$[" ~ ident ~ "]" }

// ========== Let statements ==========
let_statement = { docstring* ~ pub_modifier? ~ "let" ~ ident ~ "(" ~ params? ~ ")" ~ "->" ~ type_name ~ "=" ~ expr ~ ";" }
pub_modifier = { "pub" }
// Supports trailing comma: (a: Int, b: Bool,)
params = { param ~ ("," ~ param)* ~ ","? }
param = { ident ~ ":" ~ type_name }

// ========== Type statements ==========
type_statement = { pub_modifier? ~ "type" ~ ident ~ "=" ~ type_name ~ ";" }

// ========== Enum statements ==========
// enum Result = Ok(Int) | Error(String);
// enum Option = Some(Int) | None;
// enum MyEnum = TupleCase(Int, Bool) | StructCase { field1: Int, field2: Bool };
enum_statement = { pub_modifier? ~ "enum" ~ ident ~ "=" ~ enum_variants ~ ";" }
enum_variants = { enum_variant ~ ("|" ~ enum_variant)* }
// Variant can be: Name(Type), Name(T1, T2), Name { field: Type }, or just Name (unit)
enum_variant = { variant_name ~ enum_variant_type? }
variant_name = @{ ident }
// Type after variant name: parens for single/tuple types, braces for struct
enum_variant_type = { "(" ~ (type_name ~ ("," ~ type_name)* ~ ","?)? ~ ")" | struct_type }

// ========== Namespace Paths ==========
// Namespace path: ident or ident::ident or ident::ident::ident...
namespace_path = { ident ~ ("::" ~ ident)* }

// ========== Type Names ==========
// Qualified type: Result::Ok, or simple: Result, Int, etc.
qualified_type_name = { ident ~ "::" ~ ident }
primitive_type = { qualified_type_name | ident }
type_name = { maybe_type ~ ( "|" ~ maybe_type )* }
maybe_type = { maybe_op* ~ list_type }
maybe_op = @{ "?" }
list_type = {
    "[" ~ type_name? ~ "]" |
    tuple_type |
    struct_type |
    primitive_type
}

// Tuple type: (Type1, Type2) or (Type1, Type2, Type3, ...)
// Minimum 2 elements to distinguish from grouping
// Supports trailing comma: (Int, Bool,)
tuple_type = { "(" ~ type_name ~ "," ~ type_name ~ ("," ~ type_name)* ~ ","? ~ ")" }

// Struct type: {field1: Type1, field2: Type2}
// Supports empty struct {} and trailing comma
struct_type = { "{" ~ (struct_field_type ~ ("," ~ struct_field_type)* ~ ","?)? ~ "}" }
struct_field_type = { ident ~ ":" ~ type_name }

// ========== Unified Expressions ==========
expr = { null_coalesce_expr }

// Null coalescing (lowest precedence binary operator)
null_coalesce_expr = { or_expr ~ (null_coalesce_op ~ or_expr)* }

// Logical ops
or_expr = { and_expr ~ (or_op ~ and_expr)* }
and_expr = { not_expr ~ (and_op ~ not_expr)* }
not_expr = { not_op ~ not_expr | forall_expr }

// Quantifiers
forall_expr = { forall | comparison_expr }
forall = { "forall" ~ ident ~ in_op ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }

// Comparisons and membership
comparison_expr = { in_expr | relational_expr }
in_expr = { relational_expr ~ in_op ~ relational_expr }

relational_expr = { add_sub_expr ~ (comp_op ~ add_sub_expr)? }

// Arithmetic
add_sub_expr = { mul_div_mod_expr ~ ((add_op | sub_op) ~ mul_div_mod_expr)* }
mul_div_mod_expr = { cast_expr ~ ((mul_op | div_op | mod_op) ~ cast_expr)* }

cast_expr = { explicit_type ~ (cast_op ~ type_name)? }
cast_op = { "cast?" | "cast!" }
explicit_type = { path ~ ( "as" ~ type_name)? }

path = { primary_expr ~ ("." ~ path_segment | index_segment)* }
path_segment = { tuple_index | ident }
index_segment = { "[" ~ expr ~ index_suffix }
index_suffix = ${ "]" ~ index_op }
index_op = { "?" | "!" }
tuple_index = @{ ASCII_DIGIT+ }

// Primary expressions
primary_expr = {
    let_expr |
    if_expr |
    match_expr |
    sum |
    fold |
    rfold |
    cardinality |
    empty_typed_list | // Must come first to parse [Type]() correctly
    complex_type_cast |  // Must come before list_literal to parse [Type](expr) correctly
    list_comprehension |  // Must come before list_literal to parse correctly
    list_range | // Must come before list_literal to parse correctly
    list_literal |
    global_collection |
    qualified_var_call |   // mod::$Var(args) - must come before var_call
    qualified_var_list_call | // mod::$[VarList](args) - must come before var_list_call
    var_call |
    var_list_call |
    generic_call |   // path(args) - unifies fn_call + qualified_type_cast
    struct_call |    // path{fields} - unifies struct_type_cast + qualified_struct_cast
    string_literal |
    boolean |
    none |
    number |
    neg |
    panic |
    struct_literal |   // Must come before namespace_path to parse {field: expr} correctly
    tuple_literal |    // Must come before "(" ~ expr ~ ")" to parse correctly
    namespace_path |   // path - for ident or Option::None style unit values
    "(" ~ expr ~ ")"
}

// Type cast with complex type (list brackets or tuple)
// Examples: [LinExpr]([1,2,3]), (Int, Bool)(1, true)
// Note: We use list_type_brackets instead of list_type to avoid matching primitive types like Int
complex_type_cast = { (list_type_brackets | tuple_type) ~ "(" ~ args? ~ ")" }
list_type_brackets = { "[" ~ type_name? ~ "]" }

// Generic call with parens: path(args) or path()
// Unifies fn_call and qualified_type_cast: func(x), Type(x), Enum::Variant(x), mod::func(x)
generic_call = { namespace_path ~ "(" ~ args? ~ ")" }

// Struct-style call with braces: path { fields }
// Unifies struct_type_cast and qualified_struct_cast: Type{x:1}, Enum::Variant{x:1}
struct_call = { namespace_path ~ struct_literal }

// Tuple literal: (expr, expr) or (expr, expr, expr, ...)
// Minimum 2 elements to distinguish from grouping
// Supports trailing comma: (1, 2,)
tuple_literal = { "(" ~ expr ~ "," ~ expr ~ ("," ~ expr)* ~ ","? ~ ")" }

// Struct literal: {field1: expr1, field2: expr2}
// Supports empty struct {} and trailing comma
struct_literal = { "{" ~ (struct_field_expr ~ ("," ~ struct_field_expr)* ~ ","?)? ~ "}" }
struct_field_expr = { ident ~ ":" ~ expr }

let_expr = { "let" ~ ident ~ "=" ~ expr ~ "{" ~ expr ~ "}" }
if_expr = { "if" ~ expr ~ "{" ~ expr ~ "}" ~ "else" ~ "{" ~ expr ~ "}" }
match_expr = { "match" ~ expr ~ "{" ~ match_branch* ~ "}" }
match_branch = { ident ~ (as_op ~ type_name)? ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
sum = { "sum" ~ ident ~ in_op ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
fold = { "fold" ~ ident ~ in_op ~ expr ~ with_op ~ ident ~ "=" ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
rfold = { "rfold" ~ ident ~ in_op ~ expr ~ with_op ~ ident ~ "=" ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
cardinality = { "|" ~ expr ~ "|" }
empty_typed_list = { "[" ~ "<" ~ type_name ~ ">" ~ "]" }
list_literal = { "[" ~ "]" | "[" ~ expr ~ ("," ~ expr)* ~ "]" }
list_comprehension = { "[" ~ expr ~ "for" ~ ident ~ in_op ~ expr ~ ("for" ~ ident ~ in_op ~ expr)*  ~ (where_op ~ expr)? ~ "]" }
list_range = { "[" ~ expr ~ ".." ~ expr ~ "]" }
global_collection = { "@" ~ "[" ~ type_name ~ "]" }
var_call = { "$" ~ ident ~ "(" ~ args? ~ ")" }
var_list_call = { "$[" ~ ident ~ "]" ~ "(" ~ args? ~ ")" }
// Qualified variable calls: mod::$Var(args), mod::$[VarList](args)
qualified_var_call = { ident ~ "::" ~ "$" ~ ident ~ "(" ~ args? ~ ")" }
qualified_var_list_call = { ident ~ "::" ~ "$[" ~ ident ~ "]" ~ "(" ~ args? ~ ")" }
// Note: fn_call, qualified_type_cast, struct_type_cast, qualified_struct_cast, qualified_unit_value
// are all unified into generic_call, struct_call, and namespace_path rules.
// Supports trailing comma: f(1, 2,)
args = { arg ~ ("," ~ arg)* ~ ","? }
arg = { expr }
neg = { "-" ~ expr }
panic = { "panic!" ~ expr }

// Operators
add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "/" }
mod_op = { "%" }
comp_op = { "===" | "<==" | ">==" | "==" | "!=" | "<=" | ">=" | "<" | ">" }
in_op = @{ "in" ~ !ident_char }
null_coalesce_op = { "??" }
or_op = @{ "||" | "or" ~ !ident_char }
and_op = @{ "&&" | "and" ~ !ident_char }
not_op = @{ "!" | "not" ~ !ident_char }

where_op = @{ "where" ~ !ident_char }
with_op = @{ "with" ~ !ident_char }
as_op = @{ "as" ~ !ident_char }

boolean = @{ "true" ~ !ident_char | "false" ~ !ident_char }
none = @{ "none"  ~ !ident_char }
number = @{ "-"? ~ ASCII_DIGIT+ }

// ========== Test helpers ==========
expr_complete = { SOI ~ expr ~ EOI }
path_complete = { SOI ~ path ~ EOI }
type_name_complete = { SOI ~ type_name ~ EOI }
let_statement_complete = { SOI ~ let_statement ~ EOI }
reify_statement_complete = { SOI ~ reify_statement ~ EOI }
enum_statement_complete = { SOI ~ enum_statement ~ EOI }
ident_complete = { SOI ~ ident ~ EOI }
tuple_type_complete = { SOI ~ tuple_type ~ EOI }
tuple_literal_complete = { SOI ~ tuple_literal ~ EOI }
struct_type_complete = { SOI ~ struct_type ~ EOI }
struct_literal_complete = { SOI ~ struct_literal ~ EOI }
qualified_type_name_complete = { SOI ~ qualified_type_name ~ EOI }
import_statement_complete = { SOI ~ import_statement ~ EOI }
qualified_var_call_complete = { SOI ~ qualified_var_call ~ EOI }
qualified_var_list_call_complete = { SOI ~ qualified_var_list_call ~ EOI }
