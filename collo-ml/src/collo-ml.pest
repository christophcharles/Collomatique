// ========== General structure ==========
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ (!"##" ~ "#") ~ (!EOL ~ ANY)* }
file = { SOI ~ statement* ~ EOI }

// Raw strings with delimiter syntax
// "..." for basic strings
// ~"..."~ if you need " inside
// ~~"..."~~ if you need "~ inside, etc.
string_literal = @{
    raw_string_5 |
    raw_string_4 |
    raw_string_3 |
    raw_string_2 |
    raw_string_1 |
    raw_string_0
}

raw_string_0 = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
raw_string_1 = @{ "~\"" ~ (!"\"~" ~ ANY)* ~ "\"~" }
raw_string_2 = @{ "~~\"" ~ (!"\"~~" ~ ANY)* ~ "\"~~" }
raw_string_3 = @{ "~~~\"" ~ (!"\"~~~" ~ ANY)* ~ "\"~~~" }
raw_string_4 = @{ "~~~~\"" ~ (!"\"~~~~" ~ ANY)* ~ "\"~~~~" }
raw_string_5 = @{ "~~~~~\"" ~ (!"\"~~~~~" ~ ANY)* ~ "\"~~~~~" }

statement = { let_statement | reify_statement | type_statement | enum_statement }

docstring = ${
    "##" ~ docstring_content ~ EOL
}
docstring_content = { (!EOL ~ ANY)* }
EOL = _{ "\r\n" | "\n" | "\r" }

ident_char = _{ ASCII_ALPHANUMERIC | "_" }
ident = @{ !(reserved_keyword ~ !ident_char) ~ (ASCII_ALPHA | "_") ~ ident_char* }

// Primitive type keywords - all built-in type names
// Note: These are ordered longest-first for correct parsing
primitive_type_keyword = {
    "Constraint" |
    "LinExpr" |
    "String" |
    "Never" |
    "Bool" |
    "None" |
    "Int"
}

// All reserved keywords - primitive types plus language keywords
reserved_keyword = {
    primitive_type_keyword |
    "forall" |  // before "for"
    "false" |
    "reify" |
    "where" |
    "rfold" |
    "match" |
    "panic" |
    "cast" |
    "type" |
    "enum" |
    "fold" |
    "with" |
    "else" |
    "true" |
    "none" |
    "sum" |
    "let" |
    "pub" |
    "not" |
    "and" |
    "for" |
    "or" |
    "as" |
    "if" |
    "in"        // shortest, comes last
}

// ========== Reify statements ==========
reify_statement = { docstring* ~ "reify" ~ ident ~ "as" ~ (var_name | var_list_name) ~ ";" }
var_name = ${ "$" ~ ident }
var_list_name = ${ "$[" ~ ident ~ "]" }

// ========== Let statements ==========
let_statement = { docstring* ~ pub_modifier? ~ "let" ~ ident ~ "(" ~ params? ~ ")" ~ "->" ~ type_name ~ "=" ~ expr ~ ";" }
pub_modifier = { "pub" }
// Supports trailing comma: (a: Int, b: Bool,)
params = { param ~ ("," ~ param)* ~ ","? }
param = { ident ~ ":" ~ type_name }

// ========== Type statements ==========
type_statement = { "type" ~ ident ~ "=" ~ type_name ~ ";" }

// ========== Enum statements ==========
// enum Result = Ok(Int) | Error(String);
// enum Option = Some(Int) | None;
// enum MyEnum = TupleCase(Int, Bool) | StructCase { field1: Int, field2: Bool };
enum_statement = { "enum" ~ ident ~ "=" ~ enum_variants ~ ";" }
enum_variants = { enum_variant ~ ("|" ~ enum_variant)* }
// Variant can be: Name(Type), Name(T1, T2), Name { field: Type }, or just Name (unit)
// Note: variant_name allows primitive type names (None, Int, Bool, etc.) since the qualified
// name (e.g., "MyType::Int") is distinct from the primitive type
enum_variant = { variant_name ~ enum_variant_type? }
variant_name = @{ primitive_type_keyword ~ !ident_char | ident }
// Type after variant name: parens for single/tuple types, braces for struct
enum_variant_type = { "(" ~ (type_name ~ ("," ~ type_name)* ~ ","?)? ~ ")" | struct_type }

// ========== Type Names ==========
// Qualified type: Result::Ok, or simple: Result, Int, etc.
qualified_type_name = { ident ~ "::" ~ ident }
primitive_type = { qualified_type_name | ident | primitive_type_keyword }
type_name = { maybe_type ~ ( "|" ~ maybe_type )* }
maybe_type = { maybe_op* ~ list_type }
maybe_op = @{ "?" }
list_type = {
    "[" ~ type_name? ~ "]" |
    tuple_type |
    struct_type |
    primitive_type
}

// Tuple type: (Type1, Type2) or (Type1, Type2, Type3, ...)
// Minimum 2 elements to distinguish from grouping
// Supports trailing comma: (Int, Bool,)
tuple_type = { "(" ~ type_name ~ "," ~ type_name ~ ("," ~ type_name)* ~ ","? ~ ")" }

// Struct type: {field1: Type1, field2: Type2}
// Supports empty struct {} and trailing comma
struct_type = { "{" ~ (struct_field_type ~ ("," ~ struct_field_type)* ~ ","?)? ~ "}" }
struct_field_type = { ident ~ ":" ~ type_name }

// ========== Unified Expressions ==========
expr = { null_coalesce_expr }

// Null coalescing (lowest precedence binary operator)
null_coalesce_expr = { or_expr ~ (null_coalesce_op ~ or_expr)* }

// Logical ops
or_expr = { and_expr ~ (or_op ~ and_expr)* }
and_expr = { not_expr ~ (and_op ~ not_expr)* }
not_expr = { not_op ~ not_expr | forall_expr }

// Quantifiers
forall_expr = { forall | comparison_expr }
forall = { "forall" ~ ident ~ in_op ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }

// Comparisons and membership
comparison_expr = { in_expr | relational_expr }
in_expr = { relational_expr ~ in_op ~ relational_expr }

relational_expr = { add_sub_expr ~ (comp_op ~ add_sub_expr)? }

// Arithmetic
add_sub_expr = { mul_div_mod_expr ~ ((add_op | sub_op) ~ mul_div_mod_expr)* }
mul_div_mod_expr = { cast_expr ~ ((mul_op | div_op | mod_op) ~ cast_expr)* }

cast_expr = { explicit_type ~ (cast_op ~ type_name)? }
cast_op = { "cast?" | "cast!" }
explicit_type = { path ~ ( "as" ~ type_name)? }

path = { primary_expr ~ ("." ~ path_segment | index_segment)* }
path_segment = { tuple_index | ident }
index_segment = { "[" ~ expr ~ index_suffix }
index_suffix = ${ "]" ~ index_op }
index_op = { "?" | "!" }
tuple_index = @{ ASCII_DIGIT+ }

// Primary expressions
primary_expr = {
    let_expr |
    if_expr |
    match_expr |
    sum |
    fold |
    rfold |
    cardinality |
    empty_typed_list | // Must come first to parse [Type]() correctly
    complex_type_cast |  // Must come before list_literal to parse [Type](expr) correctly
    list_comprehension |  // Must come before list_literal to parse correctly
    list_range | // Must come before list_literal to parse correctly
    list_literal |
    global_collection |
    var_call |
    var_list_call |
    qualified_type_cast |  // Result::Ok(x) - must come before struct_type_cast and fn_call
    qualified_struct_cast | // MyEnum::StructCase { x: 1 } - must come after qualified_type_cast
    qualified_unit_value | // Option::None - must come after qualified_type_cast
    struct_type_cast |   // Must come before fn_call to parse TypeName {field: expr} correctly
    primitive_type_cast |  // Must come before fn_call to parse LinExpr(5), String(42), etc. (reserved keywords)
    fn_call |
    string_literal |
    boolean |
    none |
    number |
    neg |
    panic |
    struct_literal |   // Must come before ident to parse {field: expr} correctly
    tuple_literal |    // Must come before "(" ~ expr ~ ")" to parse correctly
    ident |
    "(" ~ expr ~ ")"
}

// Type cast with complex type (list brackets or tuple)
// Examples: [LinExpr]([1,2,3]), (Int, Bool)(1, true)
// Note: We use list_type_brackets instead of list_type to avoid matching primitive types like Int
complex_type_cast = { (list_type_brackets | tuple_type) ~ "(" ~ args? ~ ")" }
list_type_brackets = { "[" ~ type_name? ~ "]" }

// Qualified type cast: Result::Ok(x), Option::None(), Option::None(none)
// For enum variant construction with optional value
// Note: variant_name allows "None" as it's commonly used as a unit variant
qualified_type_cast = { ident ~ "::" ~ variant_name ~ "(" ~ args? ~ ")" }

// Qualified struct cast: MyEnum::StructCase { field: value }
// For enum struct variant construction
qualified_struct_cast = { ident ~ "::" ~ variant_name ~ struct_literal }

// Qualified unit value: Option::None (just the qualified name, for unit variants)
// Must come after qualified_type_cast and qualified_struct_cast so parens/braces are captured first
qualified_unit_value = { ident ~ "::" ~ variant_name }

// Struct-style type cast: TypeName {field: value}
struct_type_cast = { ident ~ struct_literal }

// Type cast with primitive type keywords that are reserved
// Examples: LinExpr(5), String(42), Int(x), Bool(1), Constraint(x)
// Note: primitive_type_keyword is defined at the top of the file
primitive_type_cast = { primitive_type_keyword ~ "(" ~ args? ~ ")" }

// Tuple literal: (expr, expr) or (expr, expr, expr, ...)
// Minimum 2 elements to distinguish from grouping
// Supports trailing comma: (1, 2,)
tuple_literal = { "(" ~ expr ~ "," ~ expr ~ ("," ~ expr)* ~ ","? ~ ")" }

// Struct literal: {field1: expr1, field2: expr2}
// Supports empty struct {} and trailing comma
struct_literal = { "{" ~ (struct_field_expr ~ ("," ~ struct_field_expr)* ~ ","?)? ~ "}" }
struct_field_expr = { ident ~ ":" ~ expr }

let_expr = { "let" ~ ident ~ "=" ~ expr ~ "{" ~ expr ~ "}" }
if_expr = { "if" ~ expr ~ "{" ~ expr ~ "}" ~ "else" ~ "{" ~ expr ~ "}" }
match_expr = { "match" ~ expr ~ "{" ~ match_branch* ~ "}" }
match_branch = { ident ~ (as_op ~ type_name)? ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
sum = { "sum" ~ ident ~ in_op ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
fold = { "fold" ~ ident ~ in_op ~ expr ~ with_op ~ ident ~ "=" ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
rfold = { "rfold" ~ ident ~ in_op ~ expr ~ with_op ~ ident ~ "=" ~ expr ~ (where_op ~ expr)? ~ "{" ~ expr ~ "}" }
cardinality = { "|" ~ expr ~ "|" }
empty_typed_list = { "[" ~ "<" ~ type_name ~ ">" ~ "]" }
list_literal = { "[" ~ "]" | "[" ~ expr ~ ("," ~ expr)* ~ "]" }
list_comprehension = { "[" ~ expr ~ "for" ~ ident ~ in_op ~ expr ~ ("for" ~ ident ~ in_op ~ expr)*  ~ (where_op ~ expr)? ~ "]" }
list_range = { "[" ~ expr ~ ".." ~ expr ~ "]" }
global_collection = { "@" ~ "[" ~ type_name ~ "]" }
var_call = { "$" ~ ident ~ "(" ~ args? ~ ")" }
var_list_call = { "$[" ~ ident ~ "]" ~ "(" ~ args? ~ ")" }
fn_call = { ident ~ "(" ~ args? ~ ")" }
// Supports trailing comma: f(1, 2,)
args = { arg ~ ("," ~ arg)* ~ ","? }
arg = { expr }
neg = { "-" ~ expr }
panic = { "panic!" ~ expr }

// Operators
add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "//" }
mod_op = { "%" }
comp_op = { "===" | "<==" | ">==" | "==" | "!=" | "<=" | ">=" | "<" | ">" }
in_op = @{ "in" ~ !ident_char }
null_coalesce_op = { "??" }
or_op = @{ "||" | "or" ~ !ident_char }
and_op = @{ "&&" | "and" ~ !ident_char }
not_op = @{ "!" | "not" ~ !ident_char }

where_op = @{ "where" ~ !ident_char }
with_op = @{ "with" ~ !ident_char }
as_op = @{ "as" ~ !ident_char }

boolean = @{ "true" ~ !ident_char | "false" ~ !ident_char }
none = @{ "none"  ~ !ident_char }
number = @{ "-"? ~ ASCII_DIGIT+ }

// ========== Test helpers ==========
expr_complete = { SOI ~ expr ~ EOI }
path_complete = { SOI ~ path ~ EOI }
type_name_complete = { SOI ~ type_name ~ EOI }
let_statement_complete = { SOI ~ let_statement ~ EOI }
reify_statement_complete = { SOI ~ reify_statement ~ EOI }
enum_statement_complete = { SOI ~ enum_statement ~ EOI }
ident_complete = { SOI ~ ident ~ EOI }
tuple_type_complete = { SOI ~ tuple_type ~ EOI }
tuple_literal_complete = { SOI ~ tuple_literal ~ EOI }
struct_type_complete = { SOI ~ struct_type ~ EOI }
struct_literal_complete = { SOI ~ struct_literal ~ EOI }
qualified_type_name_complete = { SOI ~ qualified_type_name ~ EOI }
