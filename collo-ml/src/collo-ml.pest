// ========== General structure ==========
WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ (!"##" ~ "#") ~ (!EOL ~ ANY)* }
file = { SOI ~ statement* ~ EOI }
string_literal = @{
    (
        "\\\\" | "\\\"" | ( !("\"" | "\\") ~ ANY )
    )*
}
statement = { let_statement | reify_statement }

docstring = ${
    "##" ~ docstring_content ~ EOL
}
docstring_content = { (!EOL ~ ANY)* }
EOL = _{ "\r\n" | "\n" | "\r" }

ident_char = _{ ASCII_ALPHANUMERIC | "_" }
ident = @{ !(reserved_keyword ~ !ident_char) ~ ASCII_ALPHA ~ ident_char* }
reserved_keyword = { 
    "forall" |  // before "for"
    "inter" |   // before "in"
    "union" |
    "reify" |
    "where" |
    "else" |
    "sum" |
    "let" |
    "pub" |
    "not" |
    "and" |
    "or" |
    "as" |
    "if" |
    "in"        // shortest, comes last
}

// ========== Reify statements ==========
reify_statement = { docstring* ~ "reify" ~ ident ~ "as" ~ var_name ~ ";" }
var_name = ${ "$" ~ ident }

// ========== Let statements ==========
let_statement = { docstring* ~ pub_modifier? ~ "let" ~ ident ~ "(" ~ params? ~ ")" ~ "->" ~ output_type ~ "=" ~ output ~ ";" }
pub_modifier = { "pub" }
params = { param ~ ("," ~ param)* }
param = { ident ~ ":" ~ input_type_name }

// Reserved primitive types
primitive_input_type = { "Int" | "Bool" | ident }
input_type_name = { 
    "[" ~ input_type_name ~ "]" |
    primitive_input_type
}

// Only LinExpr and Constraint outputs
output_type = { "LinExpr" | "Constraint" }
output = {
    constraint_expr |
    lin_expr
}

// ========== Constraint Expressions ==========
constraint_expr = { and_expr }
and_expr = { quantified_expr ~ (and_op ~ quantified_expr)* }
quantified_expr = { forall | primary_constraint_expr }
forall = { "forall" ~ ident ~ "in" ~ collection_expr ~ ("where" ~ computable)? ~ ":" ~ constraint_expr }
primary_constraint_expr = {
    if_constraint_expr |
    from_lin_expr |
    fn_call |
    "(" ~ constraint_expr ~ ")"
}
if_constraint_expr = { "if" ~ computable ~ "{" ~ constraint_expr ~ "}" ~ "else" ~ "{" ~ constraint_expr ~ "}" }
from_lin_expr = {
    lin_expr ~ lin_op ~ lin_expr
}
lin_op = { "<=" | ">=" | "==" }
and_op = _{ "&&" | "and" }

// ========== Linear Expressions (affine combinations of variables) ==========
lin_expr = { lin_add_sub_expr }
lin_add_sub_expr = { lin_term ~ ((add_op | sub_op) ~ lin_term)* }
lin_term = { 
    computable_primary ~ "*" ~ lin_atom |           // coefficient * variable
    "(" ~ computable ~ ")" ~ "*" ~ lin_atom |  // (expr) * variable
    lin_atom |                                // just a variable (implicit coefficient 1)
    computable_primary |                             // just a number
    "(" ~ computable ~ ")"                      // (expr) as constant
}
lin_atom = {
    sum_expr |
    if_lin_expr |
    var_call |
    fn_call |
    "(" ~ lin_expr ~ ")"
}
sum_expr = { "sum" ~ ident ~ "in" ~ collection_expr ~ ("where" ~ computable)? ~ ":" ~ lin_expr }
if_lin_expr = { "if" ~ computable ~ "{" ~ lin_expr ~ "}" ~ "else" ~ "{" ~ lin_expr ~ "}" }
var_call = { "$" ~ ident ~ "(" ~ args? ~ ")" }

// ========== Computable Expressions ==========
// One expression type for all compile-time values
computable = { computable_or }

computable_or = { computable_and ~ (cond_or_op ~ computable_and)* }
computable_and = { computable_not ~ (cond_and_op ~ computable_not)* }
computable_not = { cond_not_op ~ computable_not | computable_comparison }

computable_comparison = { computable_in | computable_relational }
computable_in = { computable_add_sub ~ in_op ~ collection_expr }
computable_relational = { computable_add_sub ~ (comp_op ~ computable_add_sub)? }

computable_add_sub = { computable_mul_div_mod ~ ((add_op | sub_op) ~ computable_mul_div_mod)* }
computable_mul_div_mod = { computable_primary ~ ((mul_op | div_op | mod_op) ~ computable_primary)* }

computable_primary = {
    if_computable |
    cardinality |
    number |
    path |
    "(" ~ computable ~ ")"
}

if_computable = { "if" ~ computable ~ "{" ~ computable ~ "}" ~ "else" ~ "{" ~ computable ~ "}" }
cardinality = { "|" ~ collection_expr ~ "|" }

add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "//" }
mod_op = { "%" }
number = @{ "-"? ~ ASCII_DIGIT+ }

comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
in_op = { "in" }
cond_or_op = _{ "||" | "or" }
cond_and_op = _{ "&&" | "and" }
cond_not_op = _{ "!" | "not" }

// Unified path for identifiers and field access
path = { ident ~ ("." ~ ident)* }

// ========== Function/Method Calls ==========
fn_call = { ident ~ "(" ~ args? ~ ")" }
args = { arg ~ ("," ~ arg)* }
arg = { computable }  // Can pass computables as argument

// ========== Collections ==========
collection_expr = { union_expr }
union_expr = { inter_expr ~ (union_op ~ inter_expr)* }
inter_expr = { diff_expr ~ (inter_op ~ diff_expr)* }
diff_expr = { collection ~ (diff_op ~ collection)? }
union_op = _{ "union" }
inter_op = _{ "inter" }
diff_op = _{ "\\" }
collection = { 
    "@" ~ "[" ~ primitive_input_type ~ "]" |
    path |
    "(" ~ collection_expr ~ ")"
}

// ========== Test helpers (enforce complete match) ==========
lin_expr_complete = { SOI ~ lin_expr ~ EOI }
constraint_expr_complete = { SOI ~ constraint_expr ~ EOI }
collection_expr_complete = { SOI ~ collection_expr ~ EOI }
path_complete = { SOI ~ path ~ EOI }
computable_complete = { SOI ~ computable ~ EOI }
var_call_complete = { SOI ~ var_call ~ EOI }
fn_call_complete = { SOI ~ fn_call ~ EOI }
input_type_name_complete = { SOI ~ input_type_name ~ EOI }
let_statement_complete = { SOI ~ let_statement ~ EOI }
reify_statement_complete = { SOI ~ reify_statement ~ EOI }
ident_complete = { SOI ~ ident ~ EOI }
